int ecall_dispatcher::enclave_init(uint8_t* hecontext, size_t context_len, uint8_t* heseckey, size_t seckey_len, uint8_t* hepubkey, size_t pubkey_len)
{
    int ret = 0;
    // if (context_len == 0)
    // {
    //     TRACE_ENCLAVE("passed hecontext is null string, context_len =0");
    //     ret = 1;
    //     goto exit;
    // }
    auto start= chrono::steady_clock::now();
    TRACE_ENCLAVE("Enclave: receive the HE context and keys");
    stringstream ess;
    string e_hecontext = string(hecontext, hecontext + context_len);
    ess << e_hecontext;
    TRACE_ENCLAVE("Enclave: reconstruct the context: ");
    e_context = Context::readPtrFrom(ess);
    e_context->printout();

    TRACE_ENCLAVE("Enclave: reconstruct the SecKey!");
    ess.str(std::string());
    ess.clear();
    string e_heseckey = string(heseckey, heseckey + seckey_len);
    ess << e_heseckey;
    activeSecKey = make_unique<SecKey>(SecKey::readFrom(ess, *e_context));

    TRACE_ENCLAVE("Enclave: reconstruct the PubKey!");
    ess.str(std::string());
    ess.clear();
    string e_hepubkey = string(hepubkey, hepubkey + pubkey_len);
    ess << e_hepubkey;
    activePubKey = make_unique<PubKey>(PubKey::readFrom(ess, *e_context));

    auto end = std::chrono::steady_clock::now();
    auto diff = end - start;
    double timeElapsed = chrono::duration <double, milli> (diff).count()/1000.0;
    cout << "------------------------------------------------------------------------" << endl;
    cout << "Enclave: Total Setup Time for HE = " << timeElapsed << " s" << endl;
    cout << "------------------------------------------------------------------------" << endl;

exit:
    TRACE_ENCLAVE("Enclave: free memory in enclave_init()!");
    e_hecontext.shrink_to_fit();
    return ret;
}




public int enclave_init(
                        [in, count=context_len] uint8_t* hecontext,
                        size_t context_len,
                        [in, count=seckey_len] uint8_t* heseckey,
                        size_t seckey_len,
                        [in, count=pubkey_len] uint8_t* hepubkey,
                        size_t pubkey_len);
















    meta.data->context.writeTo(ss);
    ContextStringTemp = ss.str();
    context_len = ContextStringTemp.size();
    hecontext = (uint8_t*)ContextStringTemp.c_str();
    cout << "Host: check size of context: " << ((double) context_len / (double)(1024 * 1024)) << " MB" << endl;

    // ss.str(std::string());
    // ss.clear();
    meta.data->secretKey.writeTo(ss);
    SeckeyStringTemp = ss.str();
    seckey_len = SeckeyStringTemp.size();
    heseckey = (uint8_t*)SeckeyStringTemp.c_str();
    cout << "Host: check size of seckey: " << ((double) seckey_len / (double)(1024 * 1024)) << " MB" << endl;

    ss.str(std::string());
    ss.clear();
    meta.data->publicKey.writeTo(ss);
    PubkeyStringTemp = ss.str();
    pubkey_len = PubkeyStringTemp.size();
    hepubkey = (uint8_t*)PubkeyStringTemp.c_str();
    cout << "Host: check size of pubkey: " << ((double) pubkey_len / (double)(1024 * 1024)) << " MB" << endl;

    cout << "Host: transform HE params (context, sk and pk) into enclave:" << endl;
    result = enclave_init(enclave, &ret, hecontext, context_len, heseckey, seckey_len, hepubkey, pubkey_len);
    if (result != OE_OK){
        cerr << "Host: transform HE params failed. OE result = " << result << endl;
        ret = 1;
        goto exit;
    }
    if (ret != 0)
    {
        cerr << "Host: transform HE params failed. ret = " << ret << endl;
        goto exit;
    }